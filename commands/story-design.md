# Story Design Command - 故事驅動系統架構設計器

為軟體開發專案執行**故事驅動的系統架構設計**，整合 SA 結構化分析與 SD 結構化設計，採用**漸進式發現**方法，深度挖掘 User Story，在關鍵節點進行確認，確保技術方案真正解決用戶問題。

**🚨 重要**: 此命令採用 User Story 優先的漸進式發現方法，通過 5 個關鍵確認點確保分析方向正確。傳統的獨立 SA/SD 分析請繼續使用 `/analysis-plan` 和 `/design-plan`。

## 使用方式
```bash
/story-design "用戶故事描述或設計需求"
```

## 🎯 Story Design 故事驅動設計定位

### **核心受眾** (雙重受眾設計)
- **AI (Claude)**: 執行故事驅動架構設計的主要執行者
  - 需要：User Story 挖掘技巧 + SA/SD 分析能力 + 互動式確認機制
  - 目標：深度理解用戶故事，生成完整的技术架構解決方案
  - 約束：每個關鍵節點必須確認，避免基於錯誤假設的分析
- **User (你) 協作者**: User Story 的提供者和最終驗證者
  - 需要：清晰的業務痛點描述和成功標準定義
  - 目標：獲得真正解決問題的技術方案，而不是技術炫技
  - 價值：參與設計過程，確保方案符合實際業務需求

### **核心價值**
- **User Story 深度挖掘**: 通過結構化方法深度理解用戶真實需求
- **漸進式發現**: 分階段確認，避免一次性分析造成的方向偏差
- **關鍵節點確認**: 在重要決策點進行驗證，確保分析方向正確
- **SA/SD 完整整合**: 一次性完成從需求分析到技術設計的完整流程
- **互動式設計**: 用戶參與整個設計過程，確保方案實用性

### **🔄 漸進式發現策略：User Story 優先**

**本方法適用於**：
- ✅ **新功能開發**: 需要深度理解用戶場景和業務需求
- ✅ **系統重構**: 需要評估現有痛點並設計改善方案
- ✅ **複雜業務問題**: 需要多輪討論才能明確需求

**不適用於**：
- ❌ **純技術優化**: 沒有明確 User Story 的技術改進
- ❌ **緊急修復**: 需要快速解決的技術問題

---

## 📚 專業知識庫 (強制自動載入)

🚨 **必須按順序載入以下核心文檔：**
1. CLAUDE.md - 專案約束和環境配置
2. session_notes.md - 當前任務狀態和歷史記錄
3. docs/ai_support/core/architect_comprehensive_guide.md - SA/SD 方法論指導

## 🎭 User Story 挖掘方法論核心

### **User Story 的戰略地位**
User Story 在故事驅動開發中是**所有技術決策的基礎**：

- **需求理解基礎**: 深度挖掘用戶背景、痛點、期望
- **方案設計導向**: 所有技術方案都必須回歸到 User Story
- **成功標準定義**: 明確什麼是「成功的解決方案」
- **驗證基準**: 所有設計决策都必須能夠解決具體的用戶問題

### **🚨 5階段漸進式發現機制** (核心創新)

**執行流程**: User Story 挖掘 → SA 分析 → ERD/狀態分析 → SD 設計 → 最終確認

#### **階段定義原則**
- **User Story 優先**: 每個階段都始於對 User Story 的重新理解
- **關鍵節點確認**: 每個階段結束後都必須獲得用戶確認
- **方向調整**: 根據用戶回饋即時調整後續分析方向
- **深度適配**: 根據 User Story 複雜度動態調整分析深度

## 🏗️ Story Design 標準結構

### **1. User Story 深度挖掘**

#### **🎯 User Story 探索框架**
- **用戶背景分析**: 誰是使用者？他們的角色和職責是什麼？
- **痛點深度挖掘**: 具體遇到什麼問題？為什麼這是個問題？
- **期望目標定義**: 理想的解決方案應該是什麼樣？
- **業務場景分析**: 在什麼情況下會遇到這個問題？
- **成功標準確認**: 怎樣才算問題被成功解決？

#### **🔍 關鍵確認點 1: User Story 理解確認**
```
基於我的理解，您的 User Story 是：

**使用者背景**: [用戶角色和背景]
**核心痛點**: [具體痛點描述]
**期望目標**: [理想的解決方案]
**成功標準**: [成功的具體標準]

請確認：
1. 這個理解是否正確？
2. 有沒有遺漏的重要點？
3. 需要調整分析重點嗎？
```

### **2. SA 結構化分析 (基於 User Story)**

#### **預查證清單設計**
- **User Story 導向**: 根據具體需求制定查證範圍
- **現有資源評估**: 評估現有系統的可用性和限制
- **技術約束識別**: 識別可能影響方案的技術約束
- **批量讀取計劃**: 優化 context 使用效率

#### **DFD 數據流分析**
- **業務流程映射**: 將 User Story 轉化為數據流圖
- **系統邊界定義**: 明確什麼需要新開發，什麼可以重用
- **外部實體識別**: 識別與系統互動的外部角色
- **數據流向分析**: 理解數據在系統中的流動路徑

#### **🔍 關鍵確認點 2: 系統理解確認**
```
基於對現有系統的分析，我發現：

**可重用組件**: [現有可用組件]
**需要開發部分**: [必須新開發的功能]
**技術約束**: [主要技術限制]
**整合點**: [與現有系統的整合方式]

這個分析是否符合您的預期？需要調整查證範圍嗎？
```

### **3. ERD + 狀態分析**

#### **🚨 檔案結構 ERD 設計** (核心交付物)
**User Story 驅動的實體關係設計**：

##### **概念 ERD (業務理解)**
基於 User Story 識別核心業務實體：
- **主要實體**: 用戶、數據、策略、結果等
- **實體關係**: 1:N、N:M 等業務關係
- **業務規則**: 實體間的約束和規則

##### **實作 ERD - 檔案結構設計**
```
[project_name]/
├── entities/                           # 數據實體定義層
│   ├── __init__.py
│   ├── [entity1].py                    # 核心業務實體
│   │   └── class [Entity1]:            # 基於 User Story 的屬性設計
│   │       ├── [field1]: [Type]        # 解決痛點的關鍵屬性
│   │       └── [field2]: [Type]        # 支援業務場景的屬性
│   └── [entity2].py                    # 相關實體
├── repositories/                       # 數據存取層
│   ├── [entity1]_repository.py         # 實體 CRUD 操作
│   └── [entity2]_repository.py
└── services/                          # 業務邏輯層
    ├── [core_business]_service.py      # User Story 核心邏輯
    └── [integration]_service.py        # 系統整合邏輯
```

#### **狀態轉換分析**
基於 User Story 的業務流程設計狀態機：
- **核心狀態識別**: 初始、處理中、完成、錯誤等
- **轉換條件**: 什麼事件觸發狀態變化
- **業務規則**: 狀態轉換的業務約束

#### **🔍 關鍵確認點 3: 數據設計確認**
```
基於您的 User Story，我設計了以下數據結構：

**核心實體**: [主要業務實體]
**關鍵屬性**: [解決痛點的核心屬性]
**實體關係**: [實體間的關係設計]
**業務狀態**: [核心業務流程的狀態變化]

這個數據設計是否能夠支援您的業務場景？
```

### **4. SD 系統架構設計**

#### **分層架構設計**
基於 User Story 選擇合適的架構模式：
- **應用層**: 直接支援 User Story 的介面層
- **業務邏輯層**: 實現核心業務邏輯的服務層
- **數據服務層**: 處理數據存取和整合的服務層
- **基礎設施層**: 支援系統運行的基礎組件

#### **🏗️ Pseudo Code 設計藍圖** (核心交付物)

##### **空殼 class 設計方式**
```python
# [project_name]/[module]/[business_component].py

class [BusinessComponent]:
    """
    User Story: [對應的用戶故事描述]
    設計意圖: [解決什麼痛點，支援什麼業務場景]
    架構位置: [在分層架構中的位置和職責]
    """

    def __init__(self, config: Dict[str, Any]):
        """
        設計意圖: [初始化邏輯和依賴注入]
        Call Stack: __init__ -> _validate_config -> _setup_dependencies
        User Story 關聯: [如何支援具體的用戶場景]
        """
        # 基於 User Story 的初始化邏輯
        pass

    def core_business_method(self, params: ParamType) -> ResultType:
        """
        設計意圖: [核心業務功能，直接解決用戶痛點]
        Call Stack: core_business_method -> _step1 -> _step2 -> _validate_result
        User Story 支援: [具體支援用戶故事的哪個部分]
        業務價值: [為用戶創造什麼價值]
        """
        # 核心業務邏輯的 pseudo code
        result1 = self._step1(params)      # 步驟1：處理用戶輸入
        result2 = self._step2(result1)     # 步驟2：核心業務邏輯
        return self._validate_result(result2)  # 步驟3：結果驗證

    def _step1(self, data: InputType) -> IntermediateType:
        """
        Call Stack: _step1 -> DataService.process -> Validation.check
        User Story 支援: [支援用戶故事的哪個子場景]
        """
        # 具體實現邏輯的 pseudo code
        pass
```

#### **🔍 關鍵確認點 4: 技術架構確認**
```
基於 User Story 和前面的分析，我設計了以下技術架構：

**系統架構**: [分層架構設計]
**核心組件**: [解決痛點的核心組件設計]
**技術選型**: [基於需求的技术選擇]
**整合方案**: [與現有系統的整合方式]

這個技術架構是否能有效解決您的問題？
```

### **5. 用戶故事與設計關聯**

#### **用戶故事細化**
將高層次的 User Story 分解為可執行的技術故事：
- **功能故事**: 具體的功能實現故事
- **整合故事**: 與現有系統的整合故事
- **驗證故事**: 測試和驗證的故事

#### **Examples 設計**
為每個技術故事設計驗證方案：
- **basic_usage.py**: 基本使用場景驗證
- **integration.py**: 系統整合驗證
- **error_handling.py**: 錯誤處理驗證

#### **🔍 關鍵確認點 5: 最終設計方案確認**
```
這是完整的解決方案設計：

**技術方案總結**: [簡潔的方案概述]
**User Story 支援**: [如何完整解決用戶問題]
**實作計劃**: [Phase 3 的實作建議]
**成功標準**: [如何驗證方案成功]

請確認：
1. 這個方案是否完全解決了您的問題？
2. 有沒有需要調整的地方？
3. 可以開始實作了嗎？
```

## 🔄 5階段漸進式發現執行指導

### **🚨 強制關鍵確認點機制**
**禁止跳過任何確認點，每個階段完成後必須獲得用戶確認才能繼續：**

#### **階段 1: User Story 深度挖掘** (必須確認)
- **🎯 目標**: 深度理解用戶背景、痛點、期望
- **📋 交付**: User Story 分析報告 + 成功標準定義
- **🔍 USER REVIEW**: User Story 理解正確性
- **⚠️ 必須確認才能進入階段 2**

#### **階段 2: SA 結構化分析** (必須確認)
- **🎯 目標**: 現有系統理解和 DFD 分析
- **📋 交付**: 系統分析報告 + DFD 圖 + 查證清單結果
- **🔍 USER REVIEW**: 系統理解正確性，分析範圍適當性
- **⚠️ 必須確認才能進入階段 3**

#### **階段 3: ERD + 狀態分析** (必須確認)
- **🎯 目標**: 數據結構設計和行為模式分析
- **📋 交付**: 檔案結構 ERD + 類別空殼 + 狀態轉換圖
- **🔍 USER REVIEW**: 數據設計合理性，業務邏輯正確性
- **⚠️ 必須確認才能進入階段 4**

#### **階段 4: SD 系統架構設計** (必須確認)
- **🎯 目標**: 技術架構設計和 Pseudo Code 藍圖
- **📋 交付**: 系統架構圖 + Pseudo Code 設計 + 技術選型
- **🔍 USER REVIEW**: 技術方案可行性，架構設計正確性
- **⚠️ 必須確認才能進入階段 5**

#### **階段 5: 最終設計確認** (最終確認)
- **🎯 目標**: 完整方案確認和實作計劃
- **📋 交付**: 完整設計文檔 + 技術故事 + Examples 設計
- **🔍 USER REVIEW**: 方案完整性，實作可行性
- **✅ 全部完成標準**: 所有 5 個確認點都通過

## 📊 Story Design 輸出標準

### **🚨 強制要求：單一 Story Design 文檔**

**核心原則**:
- ✅ **必須產生單一 Story Design 文檔**，不得分散成多個文檔
- ✅ **文檔命名**: `[project_name]_story_design.md`
- ✅ **文檔位置**: `docs/design/` 目錄
- ✅ **包含完整 SA+SD 內容**: 從 User Story 到技術方案的完整鏈路
- ❌ **禁止產出**: 多個分散的分析、設計文檔

**執行彈性**:
- ⚠️ **允許中介思考**: 過程中可以產生臨時筆記幫助組織思路
- ✅ **最終必須整合**: 最後必須整合為單一完整文檔
- ✅ **清理臨時文檔**: 整合完成後清理所有臨時文檔

### **Story Design 標準結構 (execution-plan 相容格式)**

**🚨 重要**: 此文檔格式專為 `/execution-plan` 智能分析設計，確保包含實作所需的所有關鍵資訊。

```markdown
# Story Design - [專案名稱]

## 📋 實作任務概要 (基於 User Story 分析)
- **實作目標**: [基於 User Story 的具體實作目標]
- **核心痛點**: [User Story 中識別的核心痛點]
- **成功標準**: [可測量的成功標準]
- **技術約束**: [基於專案架構的技術約束]

## 🎯 User Story 分析 (execution-plan 輸入基礎)

### User Story 深度挖掘
- **使用者背景**: [詳細的用戶角色和背景分析]
- **核心痛點**: [具體的痛點描述和影響]
- **期望目標**: [理想的解決方案描述]
- **成功標準**: [可測量的成功標準]
- **業務場景**: [具體的使用場景和流程]

### SA 結構化分析
#### DFD 數據流圖
[插入 DFD 圖 - 使用 mermaid flowchart]

#### 現有系統分析
- **可重用組件**: [識別的現有可用組件]
- **需要開發部分**: [必須新開發的功能]
- **整合點**: [與現有系統的整合方式]

## 🗂️ 數據與行為設計 (execution-plan 智能分析基礎)

### 🚨 檔案結構 ERD 設計
#### 概念 ERD
[插入概念 ERD - 使用 mermaid erDiagram]

#### 實作 ERD - 檔案目錄結構
```
[完整的檔案目錄結構]
```

#### 類別空殼設計
```python
# 基礎的 class 定義和屬性設計
class [EntityName]:
    def __init__(self):
        self.[field1]: [Type] = None  # [業務含義和 User Story 關聯]
```

### 狀態轉換圖
[插入狀態轉換圖 - 使用 mermaid stateDiagram-v2]

## 🏗️ 系統架構設計 (execution-plan 設計分析基礎)

### 系統架構圖
[插入系統架構圖 - 使用 mermaid graph 或 C4Context]

### 🚨 Pseudo Code 設計藍圖 (execution-plan 核心分析對象)
```python
# 完整的 Pseudo Code 設計，展示 Call Stack 和設計意圖
class [ComponentName]:
    """
    User Story: [對應的用戶故事]
    設計意圖: [解決什麼痛點]
    架構位置: [在系統中的位置]
    依賴模組: [具體依賴的其他模組]
    """

    def __init__(self, config: Dict[str, Any]):
        """
        設計意圖: [初始化邏輯和依賴注入]
        Call Stack: __init__ -> _validate_config -> _setup_dependencies
        User Story 支援: [如何支援用戶故事]
        """
        # 基於 User Story 的初始化邏輯
        pass

    def core_business_method(self, params: ParamType) -> ResultType:
        """
        設計意圖: [核心業務功能，直接解決用戶痛點]
        Call Stack: core_business_method -> _step1 -> _step2 -> _validate_result
        User Story 支援: [具體支援用戶故事的哪個部分]
        業務價值: [為用戶創造什麼價值]
        架構考量: [設計決策和技術原因]
        整合說明: [與其他模組的整合方式]
        """
        # 核心業務邏輯的 pseudo code
        result1 = self._step1(params)      # 步驟1：處理用戶輸入
        result2 = self._step2(result1)     # 步驟2：核心業務邏輯
        return self._validate_result(result2)  # 步驟3：結果驗證

    def _step1(self, data: InputType) -> IntermediateType:
        """
        Call Stack: _step1 -> DataService.process -> Validation.check
        User Story 支援: [支援用戶故事的哪個子場景]
        """
        # 具體實現邏輯的 pseudo code
        pass
```

### 模組間調用關係展示
```python
# 展示不同模組間的實際調用關係
# 替代抽象的模組依賴圖

# UI Layer調用Business Layer
ui_result = StrategyEngine.execute_strategy(strategy_config)

# Business Layer調用Service Layer
data = DataGateway.load_bars(instruments, time_range)

# Service Layer調用Infrastructure Layer
cached_data = CacheManager.get(cache_key)
```

## 🔗 用戶故事與技術方案關聯 (execution-plan 實作規劃基礎)

### 技術故事分解 (execution-plan 功能段落基礎)
- **US-001**: [用戶故事 1 的技術實現方案]
  - 實作複雜度: [高/中/低]
  - 依賴模組: [相關依賴]
  - 驗證方式: [Examples 設計]
- **US-002**: [用戶故事 2 的技術實現方案]
  - 實作複雜度: [高/中/低]
  - 依賴模組: [相關依賴]
  - 驗證方式: [Examples 設計]
- **US-003**: [用戶故事 3 的技術實現方案]
  - 實作複雜度: [高/中/低]
  - 依賴模組: [相關依賴]
  - 驗證方式: [Examples 設計]

### Examples 設計 (execution-plan 驗證基礎)
- **basic_usage.py**: 基本使用場景驗證 (P0)
- **integration.py**: 系統整合驗證 (P1)
- **error_handling.py**: 錯誤處理驗證 (P1)

### Phase 3 實作計劃 (execution-plan 輸入)
- **開發優先級**: [P0-P4 的優先級分級]
- **段落策略**: [如何將技術故事分解為獨立段落]
- **驗證計劃**: [每個段落的驗證方式]
- **整合時機**: [段落間的整合時機]

## 🚨 execution-plan 智能分析所需資訊

### 檔案影響分析摘要
- **關鍵檔案**: [基於設計需要修改的主要檔案，3-5個]
- **新增檔案**: [需要新建的檔案列表]
- **依賴關係**: [檔案間的依賴和調用關係]
- **向後相容性**: [現有 API 的相容性考量]

### 實作模板生成基礎
- **核心類別**: [主要實作類別的設計藍圖]
- **API 介面**: [需要實現的方法簽名]
- **Call Stack**: [完整的函數調用鏈]
- **錯誤處理**: [驗證策略和錯誤處理設計]

### 實作規範指導
- **驗證策略**: [具體的驗證方式]
- **日誌規範**: [如何使用專案日誌系統]
- **測試標準**: [測試框架要求]
- **整合約束**: [與現有專案架構的整合約束]

## ✅ 方案總結
- **User Story 完整支援**: [如何完整解決用戶問題]
- **技術方案優勢**: [相比其他方案的優勢]
- **實作可行性**: [技術實作的可行性評估]
- **execution-plan 就緒**: [此文檔包含 execution-plan 所需的所有資訊]
```

### **🚨 execution-plan 相容性要求**
**Story Design 必須確保 execution-plan 能夠進行智能分析：**

1. **完整的 Pseudo Code**: 提供足夠詳細的程式碼設計藍圖
2. **明確的 Call Stack**: 展示完整的函數調用關係
3. **檔案結構清晰**: 明確的新建/修改檔案清單
4. **技術故事分解**: 便於 execution-plan 進行功能段落規劃
5. **Examples 設計**: 為 execution-plan 的驗證機制提供基礎
6. **整合資訊**: 與現有專案架構的整合方式
7. **驗證策略**: 明確的錯誤處理和驗證方式

## 🚨 專案特定約束模板

### **Story Design 專用約束**
- **User Story 優先**: 所有技術決策必須回歸到 User Story
- **漸進式確認**: 每個關鍵節點都必須獲得用戶確認
- **實際代碼驗證**: SA 分析必須基於實際代碼查證
- **整合導向**: 設計必須考慮與現有專案架構的整合

### **通用架構約束**
- **遵循現有架構**: 必須符合專案的架構設計原則
- **使用統一組件**: 優先重用現有模組和組件
- **遵循日誌規範**: 使用專案標準的日誌系統
- **符合測試標準**: 使用專案指定的測試框架

### **互動式確認約束**
- **禁止跳過確認**: 任何情況下都不得跳過關鍵確認點
- **清晰表達**: 確認問題必須清晰易懂，避免技術術語
- **耐心等待**: 給用戶足夠時間思考和回饋
- **及時調整**: 根據用戶回饋立即調整分析方向

## 📋 Story Design 品質檢查

### **User Story 分析完整性**
- [ ] User Story 描述清晰具體
- [ ] 痛點分析深入準確
- [ ] 成功標準可測量
- [ ] 業務場景覆蓋完整

### **SA 分析品質**
- [ ] 預查證清單基於 User Story 制定
- [ ] DFD 分析完整展示數據流動
- [ ] 現有系統分析準確
- [ ] 整合方案可行

### **SD 設計品質**
- [ ] 系統架構符合 User Story 需求
- [ ] Pseudo Code 設計清晰可執行
- [ ] Call Stack 展示完整
- [ ] 技術選型合理

### **整體一致性**
- [ ] SA-SD 設計一致性
- [ ] User Story 貫穿整個設計
- [ ] 技術方案能有效解決痛點
- [ ] 實作計劃清晰可行

## 🔧 輸出和後續行動

Story Design 完成後：

### **直接輸出**
1. **設計文檔路徑**: 完整的 Story Design 文檔位置 (`docs/design/[project_name]_story_design.md`)
2. **User Story 支援總結**: 如何完整解決用戶問題
3. **技術方案概述**: 核心技術方案和架構設計
4. **execution-plan 就緒確認**: 確認文檔包含 execution-plan 所需的所有資訊

### **後續行動建議**
- **🚀 立即實作**: 使用 `/execution-plan` 基於 Story Design 進行智能分析和段落式實作規劃
- **Module Expert 協作**: 與相關領域專家討論具體實作細節
- **迭代優化**: 根據實作過程中的發現進行設計調整

### **session_notes更新**
- 記錄 Story Design 的關鍵決策和 User Story 分析
- 更新 5 個關鍵確認點的結果
- 記錄 User Story 到技術方案的完整映射關係
- 標註為 execution-plan 準備的設計文檔

### **與其他命令的整合**
- **execution-plan**: Story Design 的直接下游，基於設計文檔進行實作規劃
- **/impl**: execution-plan 生成後，由 /impl 執行具體的 Examples 驅動實作
- **/sasd**: 在複雜情況下，可回溯使用 /sasd 進行更深入的架構分析

---

**重要提醒**:
- 此命令專注於**故事驅動的系統架構設計**，通過漸進式發現確保方案正確性
- **🚨 輸出文檔專為 `/execution-plan` 智能分析設計**，確保包含實作所需的所有關鍵資訊
- **純技術分析**請繼續使用 `/analysis-plan` 和 `/design-plan`
- **執行鏈路**: `/story-design` → `/execution-plan` → `/impl`

**🚨 強制要求**:
- 必須完成所有 5 個關鍵確認點才能完成設計
- **🚨 User Story 必須貫穿整個設計過程**，所有技術決策都必須回歸到 User Story
- **🚨 輸出必須符合 execution-plan 格式要求**，包含智能分析所需的所有資訊
- **🚨 檔案結構 ERD 和 Pseudo Code 設計藍圖為核心交付物**
- **🚨 必須產生單一 Story Design 文檔**，包含完整的 SA+SD 設計內容
- 必須基於實際代碼查證進行 SA 分析
- 必須使用 mermaid 圖表並確保 Dark Theme 相容性
- 必須遵循漸進式發現方法，不得跳過任何確認點

**🔄 推薦工作流程**:
1. **User Story 探索**: 使用 `/story-design` 深度挖掘需求並生成完整設計
2. **智能實作規劃**: 使用 `/execution-plan` 基於設計文檔進行段落式實作規劃
3. **Examples 驅動實作**: 使用 `/impl` 執行具體的功能實作
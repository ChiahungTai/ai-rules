# Analysis Plan - SA結構化分析計畫書生成器

為軟體開發專案生成**SA結構化分析計畫書**，執行 Phase 1 的深度系統分析與需求理解，專為系統理解、需求分析和技術可行性評估設計。

**🚨 重要**: 此命令生成SA分析專精計畫書，專注於Phase 1的結構化分析方法論。系統設計請使用 `/design-plan`，實作執行請使用 `/execution-plan`。

## 使用方式
```bash
/analysis-plan "分析任務描述" --output "analysis-[專案名稱].md"
```

**執行後生成**: `ai-analysis/analysis/analysis-[專案名稱].md` - 完整的SA結構化分析文檔

**🚨 強制輸出**: 自動建立 `ai-analysis/analysis/` 目錄並強制寫入文檔

## 🎯 Analysis Plan SA結構化分析計畫書定位

### **核心受眾** (雙重受眾設計)
- **AI (Claude)**: 執行Phase 1 SA結構化分析的主要執行者
  - 需要：具體可執行的分析步驟和查證清單
  - 目標：生成結構化的分析文檔和檔案結構ERD
  - 約束：基於實際代碼查證，禁止經驗推測
- **User (你) Review**: SA分析結果的審核者和決策者
  - 需要：清晰易懂的分析結果和架構建議
  - 目標：理解系統現狀，決定後續設計方向
  - 價值：獲得深度系統洞察和技術可行性評估

### **核心價值**
- **系統深度理解**: 通過DFD/ERD/狀態圖全面理解現有系統
- **需求精準識別**: 基於實際代碼查證的需求分析和痛點識別
- **技術可行性評估**: 基於真實API和架構約束的可行性分析
- **SA分析文檔輸出**: 生成完整的結構化分析文檔作為Phase 2基礎

### **🔄 分析策略：傳統 SA 適用場景**

**本指南適用於**：
- ✅ **新功能開發**：需要利用現有 codebase，避免重複造輪子
- ✅ **系統重構**：需要深度理解 call stack，改善架構設計

---

#### **📦 新功能分析策略**
**主要重點**: 確保能妥善利用現有codebase，避免重複造輪子

- **現有資源查證**: 詳細分析相關程式碼內容的可利用性
  - 查證現有API和介面是否可重用
  - 識別可擴展的基礎組件和架構模式
  - 評估現有數據結構和處理邏輯的適配性
- **整合可行性**: 評估新功能與現有系統的整合點和依賴關係
- **複用策略**: 制定最大化利用現有代碼的整合方案
- **避免重複**: 識別並避免功能重複實作的風險

#### **🔧 重構分析策略**
**主要重點**: 理解目前的call stack，與user討論架構改善方案

- **Call Stack深度分析**: 追蹤完整的函數調用鏈和數據流向
  - 識別關鍵調用路徑和瓶頸點
  - 分析模組間的耦合關係和依賴鏈
  - 查證實際執行流程vs理想架構的差異
- **架構痛點識別**: 基於call stack分析識別架構問題
  - 循環依賴、緊耦合、職責不清等問題
  - 性能瓶頸和可維護性問題
  - 擴展性限制和技術債務
- **改善方案設計**: 與user討論具體的重構策略和優先級
- **風險評估**: 評估重構的影響範圍和實施風險

## 📚 專業知識庫 (強制自動載入)

🚨 **必須按順序載入以下核心文檔：**
1. CLAUDE.md - 基礎行為準則與環境約束

## 🔍 SA結構化分析方法論核心

### **SA分析的戰略地位**
SA (Structured Analysis) 在故事驅動開發中是**系統理解的基礎**：

- **系統理解基礎**: DFD數據流圖深度理解系統數據流動
- **數據結構設計**: ERD實體關係圖清晰定義數據架構
- **行為邏輯分析**: 狀態轉換圖完整分析系統狀態邏輯
- **功能架構設計**: 功能分解圖層次化理解系統功能結構

### **🚨 Phase 1 預查證清單機制** (Context效率優化)
**執行流程**: 分析前先提出查證清單 → 用戶確認 → 批量讀取 → 開始分析

#### **查證清單生成原則**
- **核心檔案優先**: 識別3-5個最關鍵的實作檔案
- **使用模式查證**: 優先尋找相關examples，若無則查證測試檔案或實際調用代碼
- **配置和依賴**: 識別關鍵配置檔案和import依賴關係
- **彈性調整**: 根據實際專案狀況調整查證範圍

#### **查證清單確認機制**
**執行原則**：
- **禁止基於經驗推測**: 任何架構、API、流程分析必須有檔案證據
- **明確標記來源**: 每個結論註明來源檔案和具體代碼片段 (如函數名、類名、關鍵邏輯)
- **區分已知未知**: 明確區分「已查證」vs「待查證」vs「推測」
- **批量讀取效率**: 用戶確認後一次性讀取，避免重複context使用

## 🏗️ SA結構化分析計畫書標準結構

### **1. 分析任務概要**
- **分析目標**: 明確的SA分析目標和範圍
- **核心問題**: 需要通過分析回答的關鍵問題
- **分析深度**: 確定需要進行的SA分析類型和深度
- **時程規劃**: Phase 1分析的時程安排和里程碑

### **2. 預查證清單設計** (SA分析基礎)
- **核心檔案識別**:
  - 主要實作檔案 (3-5個最關鍵檔案)
  - 相關examples檔案 (使用模式查證)
  - 配置檔案和依賴關係
- **查證優先級**:
  - P0: 核心功能實作檔案
  - P1: 使用範例和測試檔案
  - P2: 配置和輔助檔案
- **查證策略**:
  - 批量讀取計劃
  - 查證順序安排
  - 預期發現內容

### **3. DFD數據流圖分析規劃**

#### **Context Diagram (第0層)分析**
- **分析目標**: 定義系統與外部實體的互動關係
- **識別要素**:
  - 系統邊界定義 (什麼是系統內，什麼是系統外)
  - 外部實體識別 (誰與系統互動)
  - 數據流識別 (外部實體與系統間交換的數據)
- **驗證標準**: 所有主要互動都被捕獲

#### **Level 1 DFD分析**
- **分析目標**: 分解系統為主要功能模組，顯示模組間數據流
- **識別要素**:
  - 主要功能識別 (3-7個主要處理功能)
  - 數據存儲識別 (系統需要存儲的數據)
  - 數據流繪製 (功能間如何傳遞數據)
- **平衡檢查**: 與Context Diagram的數據流一致性

#### **Level 2 DFD分析** (必要時)
- **分析條件**: 複雜功能需要進一步分解
- **分解規則**: 保持數據流平衡，控制複雜度
- **輸出標準**: 每個功能分解為3-7個子功能

#### **典型軟體系統DFD分析重點範例**
- **數據載入流程**: 數據源 → 數據處理 → 快取管理
- **模型訓練流程**: 數據準備 → 特徵工程 → 模型訓練 → 模型評估
- **策略回測流程**: 數據載入 → 策略計算 → 信號生成 → 績效分析
- **UI展示流程**: 數據查詢 → 視覺化處理 → 互動展示

### **4. ERD實體關係圖分析規劃** <!-- ai-tag: #關鍵核心方法論 -->

#### **🚨 檔案結構呈現ERD - 核心方法論** (SA分析必備)
**戰略地位**: 這是analysis-plan的**關鍵核心交付物**，SA分析必須產出檔案結構ERD
**方法優勢**: 直接對應程式碼檔案結構，提供類別空殼設計，實作導向且易於理解

##### **📋 檔案結構ERD必須包含**
1. **完整目錄結構**: 清晰的檔案和資料夾層次組織
2. **類別空殼設計**: 每個實體類別的具體定義和屬性
3. **註解說明**: 詳細的屬性類型和業務含義註解
4. **關係映射**: 實體間關係在代碼層面的具體實現方式

#### **概念ERD (業務理解基礎)**
**量化交易系統典型實體範例**:
- **主要實體識別**:
  - Instrument (金融商品：股票、期貨、選擇權)
  - TimeFrameData (時間框架數據：日線、分鐘線、Tick數據)
  - TradingStrategy (交易策略：技術指標、ML模型)
  - Portfolio (投資組合：資產配置、持倉管理)
  - Transaction (交易記錄：買賣訊號、成交記錄)
- **實體間關係分析**:
  - Instrument (1:N) TimeFrameData
  - TradingStrategy (1:N) Transaction
  - Portfolio (1:N) Transaction

#### **🏗️ 實作ERD - 檔案結構分析** (具體交付標準)

##### **新功能ERD設計範例模板**
```
[project_name]/[module_name]/
├── entities/                           # 數據實體定義層
│   ├── __init__.py
│   ├── [entity1].py                    # 主要實體類別
│   │   └── class [Entity1]:            # - 具體屬性定義
│   │       ├── [field1]: [Type]        # 屬性1 (業務含義註解)
│   │       ├── [field2]: [Type]        # 屬性2 (業務含義註解)
│   │       └── [fieldN]: [Type]        # 屬性N (業務含義註解)
│   └── [entity2].py                    # 相關實體類別
│       └── class [Entity2]:            # - 關聯實體定義
├── repositories/                       # 數據存取層 (Repository Pattern)
│   ├── __init__.py
│   ├── [entity1]_repository.py         # 實體1 CRUD 操作
│   │   └── class [Entity1]Repository:  # 數據存取介面
│   └── [entity2]_repository.py         # 實體2 CRUD 操作
└── services/                          # 業務邏輯層
    ├── __init__.py
    └── [business_logic]_service.py     # 業務流程協調
```

##### **重構現有程式碼ERD分析重點**
- **現有Call Stack映射**: 將實際調用關係映射到檔案結構
- **架構痛點檔案識別**: 標註需要重構的具體檔案和類別
- **重構前後對比**: 提供重構前後的檔案結構對比
- **遷移路徑設計**: 具體的重構實施步驟和檔案變更計畫

### **5. 狀態轉換圖分析規劃**

#### **狀態轉換分析框架**
系統狀態識別 → 轉換條件分析 → 狀態行為定義 → 狀態驗證

#### **典型軟體系統狀態分析重點範例**
- **數據處理系統狀態**: IDLE → LOADING → PROCESSING → READY → ERROR
- **任務執行系統狀態**: INIT → RUNNING → VALIDATING → COMPLETED → FAILED
- **業務流程系統狀態**: SETUP → RUNNING → PAUSED → COMPLETED → ERROR
- **事務管理系統狀態**: PENDING → SUBMITTED → PROCESSED → CANCELLED → REJECTED

#### **狀態轉換條件分析**
- **觸發條件**: 導致狀態改變的事件和條件
- **轉換邏輯**: 狀態轉換的業務邏輯和約束
- **異常處理**: 錯誤狀態和恢復機制

### **6. 功能分解圖分析規劃**

#### **功能層次結構分析**
```
Level 0: 系統總功能
├── Level 1: 主要子系統功能
│   ├── Level 2: 模組功能
│   └── Level 2: 模組功能
├── Level 1: 主要子系統功能
└── Level 1: 主要子系統功能
```

#### **典型軟體系統功能分解範例框架**
- **數據管理子系統**: 數據載入、快取、驗證模組
- **策略開發子系統**: 策略設計、回測、評估模組
- **模型管理子系統**: 模型訓練、預測、評估模組
- **風險管理子系統**: 風險計算、限額控制、預警模組
- **用戶介面子系統**: Web介面、視覺化、報告模組

## 🔄 Phase 1 SA分段分析執行指導

### **🚨 SA分段分析要求** (強制Review機制)
**禁止一次完成整個Phase 1分析，必須分段進行並通過Review:**

#### **段落1: 系統理解 + Context Diagram**
- **🎯 目標**: 深度理解現有系統架構和繪製Context Diagram
- **📋 交付**: 系統總覽報告 + Context Diagram + 外部實體識別
- **🔍 USER REVIEW**: 系統理解正確性，Context Diagram準確性
- **⚠️ 必須Review通過才能進入段落2**

#### **段落2: 功能分析 + Level 1 DFD**
- **🎯 目標**: 主要功能識別和Level 1 DFD繪製
- **📋 交付**: 功能映射文檔 + Level 1 DFD + 數據存儲識別
- **🔍 USER REVIEW**: 功能覆蓋完整性，DFD邏輯正確性
- **⚠️ 必須Review通過才能進入段落3**

#### **段落3: 數據分析 + ERD設計**
- **🎯 目標**: 數據實體關係分析和概念ERD設計
- **📋 交付**: 概念ERD + 邏輯ERD + 數據字典
- **🔍 USER REVIEW**: ERD設計合理性，數據關係正確性
- **⚠️ 必須Review通過才能進入段落4**

#### **段落4: 狀態分析 + 功能分解**
- **🎯 目標**: 系統狀態轉換分析和詳細功能分解
- **📋 交付**: 狀態轉換圖 + 功能分解圖 + Level 2 DFD (必要時)
- **🔍 USER REVIEW**: 狀態分析完整性，功能分解層次正確性
- **✅ Phase 1完成標準**: 所有4個段落Review通過

## 📊 SA分析文檔輸出標準

### **🚨 強制要求：單一 Analysis 文檔**

**核心原則**:
- ✅ **必須產出單一 Analysis 文檔**，不得分散成多個文檔
- ✅ **文檔命名**: `[project_name]_analysis.md`
- ✅ **文檔位置**: `ai-analysis/` 目錄
- ❌ **禁止產出**: 多個分散的分析、圖表、清單文檔

**原因**:
1. **便於 Phase 2 設計**: SD 設計需要完整的 SA 分析基礎，單一文檔便於查閱
2. **文檔管理清晰**: 避免多個分散文檔造成管理混亂
3. **符合標準流程**: SA 分析 → 單一 Analysis 文檔 → SD 設計 → 單一 Design 文檔

**執行彈性**:
- ⚠️ **允許中介文檔**: SA 分析過程中可以產出中介文檔幫助組織思路
- ✅ **最終必須整合**: 最後必須整合所有中介文檔為單一 Analysis 文檔
- ✅ **清理中介文檔**: 整合完成後刪除中介文檔，保持文檔管理清晰

---

### **傳統 SA 文檔標準結構** (新功能/重構場景)
```markdown
# Analysis & Design - [專案名稱]

## 📊 SA結構化分析 (Phase 1)

### Context Diagram
[插入Context Diagram - 使用mermaid flowchart]

### Level 1 DFD
[插入Level 1 DFD - 使用mermaid flowchart]

### 🚨 檔案結構呈現ERD (核心交付物)
#### 概念ERD
[插入概念ERD - 使用mermaid erDiagram]

#### 實作ERD - 檔案目錄結構
```
[必須包含完整的檔案目錄結構，如：]
[project_name]/[module]/
├── entities/
│   ├── [entity1].py
│   └── [entity2].py
├── repositories/
└── services/
```

#### 類別空殼設計 (具體實作導向)
```python
# [entity1].py
class [Entity1]:
    """[實體業務描述]"""
    def __init__(self):
        self.[field1]: [Type] = None  # [業務含義註解]
        self.[field2]: [Type] = None  # [業務含義註解]
        # ... 其他屬性

# [entity2].py
class [Entity2]:
    """[實體業務描述]"""
    def __init__(self):
        self.[field1]: [Type] = None  # [業務含義註解]
        self.[foreign_key]: str = None  # 關聯到 [Entity1] 的外鍵
```

### 狀態轉換圖
[插入狀態轉換圖 - 使用mermaid stateDiagram-v2]

### 功能分解圖
[插入功能分解圖 - 使用mermaid graph]

## 🔗 SA分析總結
- **系統理解總結**: 核心發現和洞察
- **需求識別總結**: 關鍵需求和約束條件
- **檔案結構ERD價值**: 檔案結構設計的業務價值和技術優勢
- **技術可行性評估**: 實作可行性和風險評估
- **Phase 2 設計基礎**: 為SD設計提供的基礎資訊
```

### **🚨 SA分析必須交付的核心內容**
1. **檔案目錄結構**: 完整且清晰的資料夾和檔案組織
2. **類別空殼代碼**: 每個實體的具體class定義和屬性
3. **註解說明**: 每個屬性的類型和業務含義
4. **關係實現**: 實體間關係的具體代碼實現方式
5. **整合說明**: 如何與現有codebase整合的具體方案

## 🚨 專案特定約束模板

### **SA分析專用約束範例**
> **注意**: 以下約束需要根據實際專案的 CLAUDE.md 進行客製化

- **驗證策略**: 定義專案的驗證機制（如：assert優先原則）
- **實際代碼優先**: 所有分析基於實際代碼查證，禁止經驗推測
- **來源標記要求**: 每個分析結論必須標註檔案來源和代碼特徵
- **批量查證機制**: 預查證清單確認後批量讀取，優化context使用

### **Mermaid圖表規範**
- **Dark Theme相容**: 避免純白色背景，確保dark theme可讀性
- **推薦圖表類型**:
  - 數據流圖: `flowchart TD/LR`
  - 實體關係: `erDiagram`
  - 狀態轉換: `stateDiagram-v2`
  - 功能分解: `graph TD/LR`

## 📋 Analysis Plan計畫書品質檢查

### **SA分析規劃完整性**
- [ ] 預查證清單具體且可執行
- [ ] DFD分析規劃層次清晰 (Context → Level 1 → Level 2)
- [ ] **🚨 檔案結構ERD分析**：包含概念和實作兩個層次
- [ ] **🚨 檔案目錄結構**：必須提供完整的檔案和資料夾組織
- [ ] **🚨 類別空殼設計**：必須提供具體的class定義和屬性註解
- [ ] 狀態轉換分析涵蓋主要系統狀態
- [ ] 功能分解分析有明確的層次結構

### **分段執行可行性**
- [ ] 4個段落劃分合理且相對獨立
- [ ] 每個段落有明確的目標和交付物
- [ ] Review檢查點設計清晰可執行
- [ ] 段落間的依賴關係明確

### **專案相關性檢查**
- [ ] SA分析重點符合軟體系統特徵
- [ ] 查證清單包含關鍵模組檔案
- [ ] 分析方法適合數據處理特性

## 🔧 輸出和後續行動

Analysis Plan生成完成後：

### **直接輸出**
1. **計畫書路徑**: 提供完整的Analysis Plan檔案位置
2. **分析範圍摘要**: SA分析的核心範圍和重點
3. **預查證清單**: 具體的檔案查證清單等待用戶確認
4. **分段執行提醒**: 強調4段落分段執行和Review機制

### **後續行動建議**
- **開始執行**: 使用 `/sasd` 基於此計畫書執行Phase 1 SA分析
- **查證確認**: 確認預查證清單後開始批量讀取和分析
- **分段Review**: 每個段落完成後進行USER REVIEW
- **Phase 2準備**: SA分析完成後使用 `/design-plan` 規劃SD設計

### **後續行動記錄**
- 記錄Analysis Plan生成結果和SA分析規劃
- 更新預查證清單和分段執行計劃
- 記錄SA分析重點和預期發現

---

**重要提醒**:
- 此命令專注於**傳統 SA 結構化分析**（新功能開發/系統重構）
- **舊系統廢棄場景**：請使用 `/gap-analysis` 專用指南
- SD 設計規劃請使用 `/design-plan`
- 實作執行規劃請使用 `/execution-plan`

**🚨 強制要求**:
- 必須包含預查證清單機制
- 必須設計 4 段落分段執行和 Review 機制
- **🚨 檔案結構 ERD 為核心交付物**：必須產出完整的檔案目錄結構和類別空殼設計
- **🚨 實作導向 ERD**：ERD 必須包含具體可實作的代碼結構，而非抽象概念圖
- SA 分析必須基於實際代碼查證，禁止經驗推測
- 必須使用 mermaid 圖表並確保 Dark Theme 相容性
- 必須產出單一 Analysis 文檔（允許中介文檔但最終需整合）
# /lessons 命令設計文檔

## 🎯 目標

從對話歷史中提取目錄的程式碼精隨，生成 CLAUDE.md 和技術規格文檔，讓 AI 不用讀取所有程式碼就能快速理解模組用途和重要實作細節。

---

## 📋 核心概念

### 什麼應該被提取？

#### ✅ 應該提取
- **模組用途** - 這個目錄做什麼？核心功能是什麼？
- **目錄結構** - 重要檔案和子目錄的組織方式
- **核心 API/Class** - 主要類別和函數的用途描述
- **設計決策** - 為什麼這樣設計？選擇了什麼方案？
- **重要實作細節** - 有什麼特殊實作？需要注意什麼？
- **模組間關係** - 跟其他模組如何互動？依賴什麼？
- **常見陷阱** - 這個模組容易犯什麼錯誤？

**🤖 AI 價值強調**: 對於 AI 協作開發，目錄結構和核心 API 的簡要描述極其重要，能讓 AI 快速建立代碼庫的心理地圖，避免重複解析大量檔案。

#### ❌ 不應該提取
- 具體的程式碼實作細節
- 環境設定問題
- IDE 相關問題
- 版本控制流程

### 📋 Spec 技術規格

Spec 是技術規格文檔，記錄重要的技術決策和實作標準：

#### ✅ 應該提取的 Spec 內容
- **技術規格** - API 介面定義、資料結構、性能要求
- **實作標準** - 編碼規範、測試覆蓋率、錯誤處理標準
- **架構決策** - 系統設計選擇、技術棧決策、第三方依賴
  - **決策背景** - 為什麼需要做這個決策
  - **Tradeoff 分析** - 選擇的優缺點、犧牲了什麼、得到了什麼
  - **重要決策點** - 關鍵的技術選擇和轉折點
  - **替代方案考量** - 為什麼不選擇其他方案
- **驗收標準** - 功能驗收條件、性能基準、安全要求
- **版本相容性** - API 版本政策、向後相容性要求
- **部署規格** - 環境需求、配置參數、監控指標

#### 🎯 Spec 價值
- **一致性**: 確保團隊遵循相同的技術標準
- **可維護性**: 記錄重要的技術決策，方便後續維護
- **知識傳承**: 新成員能快速理解技術規格和決策背景
- **品質保證**: 明確的驗收標確保開發品質

### 提取來源

```
對話歷史
├── 模組討論
│   └─> "這個目錄用來做..." → 用途記錄
│
├── 設計討論
│   └─> "為什麼選擇 A 而不是 B" → 決策記錄
│
├── 實作過程
│   └─> "注意要處理這個邊界條件" → 重要細節
│
└── 問題解決
    └─> "這裡容易出錯，需要..." → 陷阱記錄
```

---

## 🏗️ 實作設計

### 整體架構

```
┌─────────────────────────────────────────────────┐
│              /lessons 命令流程                   │
├─────────────────────────────────────────────────┤
│                                                  │
│  1. 掃描對話歷史                                 │
│     └─> 提取與該目錄相關的對話                   │
│                                                  │
│  2. 識別關鍵資訊                               │
│     ├─> 模組用途                                 │
│     ├─> 設計決策                                 │
│     ├─> 實作細節                                 │
│     ├─> 模組關係                                 │
│     └─> 技術規格                                 │
│                                                  │
│  3. 提取知識精華                                │
│     ├─> 去除重複內容                             │
│     ├─> 關聯相關概念                             │
│     └─> 結構化整理                               │
│                                                  │
│  4. 生成文檔                                    │
│     ├─> 讀取現有內容                             │
│     ├─> 合併新知識                               │
│     ├─> 自洽性檢查                               │
│     ├─> 保持簡潔                                 │
│     └─> 寫入檔案                                 │
│                                                  │
└─────────────────────────────────────────────────┘
```

### 📋 Spec 處理流程

#### 1. 優先檢查現有文檔

**執行順序**:
```
1. 檢查 specs/ 目錄是否存在對應的 spec 文檔
   ├─> 存在：讀取現有文檔
   └─> 不存在：使用模板建立新文檔

2. 分析現有文檔結構
   ├─> 識別現有章節和內容
   ├─> 標記需要更新的部分
   └─> 保持原有格式和風格

3. 萃取新規格資訊
   ├─> 從對話歷史提取新內容
   ├─> 與現有內容比對
   └─> 識別重複和衝突
```

#### 2. 文檔更新策略

**更新原則**:
- **增量更新**: 只更新有變化的部分
- **保留歷史**: 重要的決策記錄不刪除
- **版本標記**: 註明更新時間和來源
- **衝突解決**: 新內容優先，但保留舊記錄

#### 3. 自洽性檢查

**檢查清單**:
- [x] **格式一致性**: 全文檔使用相同的標題階層和格式
- [x] **術語一致性**: 相同概念使用統一術語
- [x] **邏輯一致性**: 不同章節間沒有矛盾陳述
- [x] **版本一致性**: 所有引用的版本號保持一致
- [x] **連結有效性**: 內部連結和參考都正確有效

---

## 🔧 命令介面設計

### 基本用法

```bash
# 1. 掃描當前目錄，生成 CLAUDE.md
/lessons

# 2. 掃描指定目錄
/lessons watchlist/
/lessons finml/datacore/

# 3. 預覽模式（不寫入，只顯示）
/lessons --dry-run

# 4. 指定對話範圍
/lessons --last 20           # 最近 20 次對話
/lessons --since "2024-01-01"  # 指定日期之後

# 5. Spec 萃取功能
/lessons --spec              # 同時萃取 spec 並生成至 specs/ 目錄
/lessons --spec-only         # 只萃取 spec，不生成 CLAUDE.md
/lessons --spec-format api   # 指定 spec 格式：api, design, deployment

# 6. Spec 檢查和更新功能
/lessons --spec-check        # 檢查現有 spec 文檔的一致性
/lessons --spec-update       # 更新現有 spec 文檔（增量更新）
/lessons --spec-merge        # 智慧合併新舊規格內容
/lessons --spec-validate     # 驗證 spec 文檔的自洽性和完整性
```

### 輸出範例

```
🔍 分析 watchlist/ 目錄的對話歷史...
   找到 15 則相關對話

📊 提取知識精華中...
   ✓ 模組用途：股票觀察清單管理
   ✓ 設計決策：使用 Actor 模式
   ✓ 重要細節：事件發布機制
   ✓ 模組關係：依賴 datacore 和 notification

💾 生成 CLAUDE.md...
   ✓ watchlist/CLAUDE.md 已更新

📋萃取技術規格...
   ✓ API 介面定義 (3 項)
   ✓ 實作標準 (5 項)
   ✓ 驗收標準 (4 項)
   ✓ 架構決策 (2 項)
   ✓ Tradeoff 分析 (1 項)

📝 檢查現有 SPEC 文檔...
   ✓ 發現 specs/watchlist-spec.md 存在
   ✓ 讀取現有文檔結構
   ✓ 分析需要更新的部分

🔄 智慧合併內容...
   ✓ 保留原有重要決策記錄
   ✓ 新增最新規格要求
   ✓ 解決內容衝突 (2 項)

🔍 執行自洽性檢查...
   ✓ 格式一致性：通過
   ✓ 術語一致性：通過
   ✓ 版本一致性：通過
   ✓ 邏輯一致性：通過
   ⚠️  連結檢查：發現 1 個失效連結，已修復

💾 生成 SPEC 文檔...
   ✓ specs/watchlist-spec.md 已更新

✅ 完成！提取了 4 項核心知識 + 15 項技術規格（包含 2 個重要決策點和 1 個 Tradeoff 分析），文檔自洽性驗證通過。
```

---

## 📄 CLAUDE.md 模板結構

### 標準模板

```markdown
# {目錄名稱} - {簡短描述}

## 🎯 模組用途
用來做什麼？核心功能是什麼？

## 🏗️ 核心設計
關鍵的架構選擇和設計模式。

## ⚠️ 重要注意事項
實作時需要特別注意的地方。

## 🔗 相關模組
跟其他模組的依賴關係和互動方式。
```

### 範例

```markdown
# watchlist/ - 股票觀察清單模組

## 🎯 模組用途
用於管理和監控股票觀察清單，支援自動檢查股價變化和通知。

## 📁 目錄結構
```
watchlist/
├── __init__.py              # 模組初始化
├── manager.py              # WatchlistManager (核心管理類)
├── monitor.py              # PriceMonitor (價格監控類)
├── notifier.py             # NotificationSender (通知發送類)
└── config/                 # 配置檔案目錄
    └── default.yaml        # 預設觀察清單配置
```

## 🔧 核心 API/Class
- **WatchlistManager**: 主要管理類，負責觀察清單的 CRUD 操作
- **PriceMonitor**: 價格監控引擎，定期檢查股價變化
- **NotificationSender**: 通知發送器，整合多種通知渠道
- **MessageBus**: 事件總線，處理模組間異步通訊

## 🏗️ 核心設計
- 使用 Actor 模式處理非同步事件
- Polars 處理大量股票資料
- MessageBus 機制進行模組間通訊

## ⚠️ 重要注意事項
- 事件發布必須透過 MessageBus，不可直接呼叫方法
- MultiIndex 欄位存取要用 tuple 格式
- 定時任務需要考慮執行時間

## 🔗 相關模組
- **datacore**: OHLCV 資料來源
- **notification**: 通知系統
- **config**: 觀察清單配置
```

---

## 🎯 知識提取規則

### 觸發條件

#### 1. 模組用途識別
```
關鍵詞：
- "這個目錄用來"
- "模組的功能是"
- "主要負責"
- "這裡做什麼"

提取：
- 模組的核心目的
- 主要功能描述
- 使用場景
```

#### 2. 設計決策識別
```
關鍵詞：
- "為什麼選擇"
- "決定用"
- "設計原因是"
- "採用這種方式"

提取：
- 設計背景
- 技術選擇理由
- 架構決策
```

#### 3. 重要細節識別
```
關鍵詞：
- "要注意"
- "特別處理"
- "不要忘記"
- "這裡容易錯"

提取：
- 實作細節
- 邊界條件
- 常見錯誤
```

#### 4. 模組關係識別
```
關鍵詞：
- "依賴"
- "調用"
- "跟...互動"
- "需要...支援"

提取：
- 依賴關係
- 介面定義
- 資料流向
```

#### 5. Spec 規格識別
```
技術規格關鍵詞：
- "API 介面要..."
- "回傳格式應該是..."
- "性能要求是..."
- "需要支援..."

實作標準關鍵詞：
- "編碼規範要求..."
- "測試覆蓋率必須..."
- "錯誤處理要..."
- "命名規則是..."

架構決策關鍵詞：
- "決定採用..."
- "選擇這個方案是因為..."
- "技術棧包括..."
- "架構設計為..."

Tradeoff 分析關鍵詞：
- "優點是...但是..."
- "雖然...但是..."
- "為了...我們犧牲了..."
- "這個選擇的代價是..."
- "比起...我們選擇..."
- "權衡後決定..."

決策背景關鍵詞：
- "面臨的問題是..."
- "需要解決的核心痛點..."
- "基於以下考慮..."
- "之所以這樣設計是因為..."
- "決策的動機是..."
```

### 去重邏輯

```python
def is_duplicate(new_knowledge, existing_knowledge):
    """
    判斷是否為重複知識

    合併策略：
    - 相同概念保留更詳細的描述
    - 互補資訊進行合併
    - 過時資訊標記更新
    """
    pass
```

---

## 🔄 更新策略

### 合併規則

1. **新增知識**: 直接添加到對應分類
2. **更新知識**:
   - 如果更詳細，替換舊版本
   - 如果補充資訊，合併內容
3. **刪除知識**:
   - 過時的資訊（標記為已過時）
   - 重複內容（保留較好的版本）

---

> 💡 **設計哲學**: 讓對話中的程式碼精華自動沉澱為模組說明書，AI 下次遇到這個目錄時，讀 CLAUDE.md 就能快速理解「這裡做什麼、怎麼做的、要注意什麼」，而不需要讀取所有程式碼。

> 🤖 **AI 導航價值**: 包含目錄結構和核心 API 描述的 CLAUDE.md 對 AI 協作開發極具價值，如同為 AI 提供了精確的地圖和詞彙表，大幅提升理解效率和準確性。

> 📋 **Spec 規格價值**: 技術規格文檔確保團隊遵循統一的技術標準，記錄重要的設計決策，並提供明確的驗收標準，是專案長期維護和知識傳承的關鍵。